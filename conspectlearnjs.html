<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>conspect</title>
</head>
<body> "use strict" <br>
    <!-- <script>  alert('я учу джаваскрипт')</script>  -->
    <!-- <script src="21alert.js"></script> -->
    
    let - создать переменную. для хранения данных и тд<br>
    <!-- <script>
    let message = 'hello'
    alert(message)
    </script> -->
    <p>let user = 'John', age = 25, message = 'Hello';
    можно в одну строку. 
    var вместо let в старых скриптах</p>
    <!-- <script src="24let.js"></script> -->
    <p>const - объявить константу (не меняется. можно использовать для цвета и тд const COLOR_RED = "#F00";)</p>
    <p>Итого
объявить переменные для хранения данных  var let const.
        
let – это современный способ объявления.
var – это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое слово "var" на случай, если это всё-таки вам понадобится.
const – похоже на let, но значение переменной не может изменяться.
Переменные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.</p>
        <!-- <script src="24zada4i.js"></script> <br> -->

        <!-- <script src="25type.js"></script> -->
<p>типы данных</p>
число let n = 123; n = 12.345; <br>
<p>BigInt - для больших чисел.
символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;</p>
<p>строка</p> 
Строка (string) в JavaScript должна быть заключена в кавычки.

let str = "Привет";<br>
let str2 = 'Одинарные кавычки тоже подойдут';<br>
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`; <br>

Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. 
Например: <!--<script src="25type.js"></script>--> <br>

<p>булевый тип</p>
Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено
Булевые значения также могут быть результатом сравнений:

let isGreater = 4 > 1;

alert( isGreater ); // true (результатом сравнения будет "да") <br>

<p>null</p>
let age = null;
<p>undefined</p>
let age;
alert(age); // выведет "undefined"
Технически мы можем присвоить значение undefined любой переменной:
let age = 123;
// изменяем значение на undefined
age = undefined;
alert(age); // "undefined"
<br>
<p>Тип object (объект) – особенный.</p>
<p>Оператор typeof</p>
У него есть две синтаксические формы:

Синтаксис оператора: typeof x.
Синтаксис функции: typeof(x).
Другими словами, он работает со скобками или без скобок. Результат одинаковый.

Вызов typeof x возвращает строку с именем типа:
typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1)
typeof null // "object"  (2)
typeof alert // "function"  (3) 

<p>Итого
    В JavaScript есть 8 основных типов данных.
    
    Семь из них называют «примитивными» типами данных:
    number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
    bigint для целых чисел произвольной длины.
    string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    boolean для true/false.
    null для неизвестных значений – отдельный тип, имеющий одно значение null.
    undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
    symbol для уникальных идентификаторов.
    И один не является «примитивным» и стоит особняком:
    object для более сложных структур данных.
    Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
    
    Имеет две формы: typeof x или typeof(x).
    Возвращает строку с именем типа. Например, "string".
    Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
    В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.</p>

<p> alert(показывает текст</p>
<p>prompt
    Функция prompt принимает два аргумента:
    
    result = prompt(title, [default]);
    Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
    title - Текст для отображения в окне.
    default - Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.

    let age = prompt('Сколько тебе лет?', 100);
    alert(`Тебе ${age} лет!`); // Тебе 100 лет!</p>

<p>confirm
Синтаксис:

result = confirm(question);
Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

Результат – true, если нажата кнопка OK. В других случаях – false.

Например:

let isBoss = confirm("Ты здесь главный?");

alert( isBoss ); // true, если нажата OK</p>
<p>Итого
    Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:
    
    alert
    показывает сообщение.
    prompt
    показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
    confirm
    показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
    Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.
    
    На все указанные методы распространяются два ограничения:
    
    Расположение окон определяется браузером. Обычно окна находятся в центре.
    Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
    Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.
    
    </p> <a href="26alertpromptconfirm.html">27alertpromptconfirm</a>
<p>Строковое преобразование
    Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.
    
    Например, alert(value) преобразует значение к строке.
    
    Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:
    
    let value = true;
    alert(typeof value); // boolean
    
    value = String(value); // теперь value это строка "true"
    alert(typeof value); // string <!--<script src="27preobrazovanie.js"></script></p>-->
<p>Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

    let str = "123";
    alert(typeof str); // string
    
    let num = Number(str); // становится числом 123
    
    alert(typeof num); // number</p>
<p>Итого
    Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.
    
    Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
    
    Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
    
    Преобразование подчиняется правилам:
    
    Значение	Становится…
    undefined	NaN
    null	0
    true / false	1 / 0
    string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
    Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
    
    Подчиняется правилам:
    
    Значение	Становится…
    0, null, undefined, NaN, ""	false
    любое другое значение	true
    Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:
    
    undefined при численном преобразовании становится NaN, не 0.
    "0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.</p>
<p>Операторы ++ и -- могут быть расположены не только после, но и до переменной.

    Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
    «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
    Обе эти инструкции делают одно и то же: увеличивают counter на 1.br
    let counter = 1;
    let a = ++counter; // (*)br
    
    alert(a); // 2
    В строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2.
    <br>
    Теперь посмотрим на постфиксную форму:
    
    let counter = 1;
    let a = counter++; // (*) меняем ++counter на counter++
    <br>
    alert(a); // 1
    В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1. <br>
</p>
<p>Итого
    Операторы сравнения возвращают значения логического типа.
    Строки сравниваются посимвольно в лексикографическом порядке.
    Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
    Значения null и undefined равны == друг другу и не равны любому другому значению.
    Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.</p>
<p>Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода<br>
    Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно<br>
    Иногда нужно проверить несколько вариантов условия. Для этого используется блок else if. <br>
    let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Это слишком рано...' ); 
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
<br>
Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

Синтаксис:

let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2. let accessAllowed = (age > 18) ? true : false;<br>
<!--<script src="210ifelse.js"></script>--> <a href="210javascriptname.html">210javascriptname.html</a> <a href="210promptnumber.html">210</a> <!--<script src="210result.js"></script> -->
<!-- <script src="210logindirector.js"></script> -->
</p>
<p>Обычно оператор || используется в if для проверки истинности любого из заданных условий.

    К примеру:
    
    let hour = 9;
    
    if (hour < 10 || hour > 18) {
      alert( 'Офис закрыт.' );
    }
    Можно передать и больше условий:
    
    let hour = 12;
    let isWeekend = true;
    
    if (hour < 10 || hour > 18 || isWeekend) {
      alert( 'Офис закрыт.' ); // это выходной
    } При выполнении ИЛИ || с несколькими значениями:

    result = value1 || value2 || value3;
    Оператор || выполняет следующие действия:
    
    Вычисляет операнды слева направо.
    Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
    Если все операнды являются ложными (false), возвращает последний из них.<br>
    
</p> <p>И «&&» находит первое ложное значение
    При нескольких подряд операторах И:
    
    result = value1 && value2 && value3;
    Оператор && выполняет следующие действия:
    
    Вычисляет операнды слева направо.
    Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
    Если все операнды были истинными, возвращается последний.
    // Если первый операнд истинный,
    // И возвращает второй:
    alert( 1 && 0 ); // 0
    alert( 1 && 5 ); // 5
    
    // Если первый операнд ложный,
    // И возвращает его. Второй операнд игнорируется
    alert( null && 5 ); // null
    alert( 0 && "no matter what" ); // 0</p>
<p>! (НЕ)
    Оператор НЕ представлен восклицательным знаком !.
    
    Синтаксис довольно прост:
    
    result = !value;
    Оператор принимает один аргумент и выполняет следующие действия:
    
    Сначала приводит аргумент к логическому типу true/false.
    Затем возвращает противоположное значение.
    Например:
    
    alert( !true ); // false
    alert( !0 ); // true
    В частности, двойное НЕ !! используют для преобразования значений к логическому типу:
    
    alert( !!"non-empty string" ); // true
    alert( !!null ); // false
    То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.
    
    Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:
    
    alert( Boolean("non-empty string") ); // true
    alert( Boolean(null) ); // false
    Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.</p> 
    <!-- <script src="212notandor.js"></script>  -->
    <a href="212login.html">210admin</a>
<p>
    Оператор нулевого слияния представляет собой два вопросительных знака ??.

Так как он обрабатывает null и undefined одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение «определено», если оно не равняется ни null, ни undefined.

Результат выражения a ?? b будет следующим:

если a определено, то a,
если a не определено, то b.
Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
</p>
<p>Цикл while имеет следующий синтаксис:

    while (condition) {
      // код
      // также называемый "телом цикла"
    }
    Код из тела цикла выполняется, пока условие condition истинно.
    
    Например, цикл ниже выводит i, пока i < 3:
    
    let i = 0;
    while (i < 3) { // выводит 0, затем 1, затем 2
      alert( i );
      i++;
    }</p>
<p>Цикл «do…while»
    Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:
    
    do {
      // тело цикла
    } while (condition);
    Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.
    
    Например:
    
    let i = 0;
    do {
      alert( i );
      i++;
    } while (i < 3);
    Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.</p>
<p>Цикл «for»
    Более сложный, но при этом самый распространённый цикл — цикл for.
    
    Выглядит он так:
    
    for (начало; условие; шаг) {
      // ... тело цикла ...
    }
    Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:
    
    for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
      alert(i);
    }
    <p>// for (let i = 0; i < 3; i++) alert(i)

        // Выполнить начало
        let i = 0;
        // Если условие == true → Выполнить тело, Выполнить шаг
        if (i < 3) { alert(i); i++ }
        // Если условие == true → Выполнить тело, Выполнить шаг
        if (i < 3) { alert(i); i++ }
        // Если условие == true → Выполнить тело, Выполнить шаг
        if (i < 3) { alert(i); i++ }
        // ...конец, потому что теперь i == 3</p></p>
<p>while – Проверяет условие перед каждой итерацией.
    do..while – Проверяет условие после каждой итерации.
    for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
    Чтобы организовать бесконечный цикл, используют конструкцию while (true). При этом он, как и любой другой цикл, может быть прерван директивой break.
    
    Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
    
    Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.</p>
<a href="213while.html">213while</a>
<p>Прерывание цикла: «break»
  Обычно цикл завершается при вычислении условия в false.
  
  Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.
  
  Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:
  
  let sum = 0;
  
  while (true) {
  
    let value = +prompt("Введите число", '');
  
    if (!value) break; // (*)
  
    sum += value;
  
  }
  alert( 'Сумма: ' + sum );</p>
  <p>Переход к следующей итерации: continue
    Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).
    
    Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
    
    Например, цикл ниже использует continue, чтобы выводить только нечётные значения:
    
    for (let i = 0; i < 10; i++) {
    
      // если true, пропустить оставшуюся часть тела цикла
      if (i % 2 == 0) continue;
    
      alert(i); // 1, затем 3, 5, 7, 9
    }
    Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). Таким образом alert вызывается только для нечётных значений.
    
    Директива continue позволяет избегать вложенности
    Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:
    
    for (let i = 0; i < 10; i++) {
    
      if (i % 2) {
        alert( i );
      }
    
    }
    С технической точки зрения он полностью идентичен. Действительно, вместо continue можно просто завернуть действия в блок if.
    
    Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри if более длинный, то это ухудшает читаемость, в отличие от варианта с continue.</p>
<p>Конструкция "switch"
  Конструкция switch заменяет собой сразу несколько if.
  
  Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
  
  Синтаксис
  Конструкция switch имеет один или более блок case и необязательный блок default.
  
  Выглядит она так:
  
  switch(x) {
    case 'value1':  // if (x === 'value1')
      ...
      [break]
  
    case 'value2':  // if (x === 'value2')
      ...
      [break]
  
    default:
      ...
      [break]
  }
  Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
  Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
  Если ни один case не совпал – выполняется (если есть) вариант default.
  let a = 2 + 2;

  switch (a) {
    case 3:
      alert( 'Маловато' );
      break;
    case 4:
      alert( 'В точку!' );
      break;
    case 5:
      alert( 'Перебор' );
      break;
    default:
      alert( "Нет таких значений" );
  }</p>

</body>
</html>